Index: app/src/main/java/com/example/id/data/dao/WorkdayEventDao.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.id.data.dao\r\n\r\nimport androidx.room.Dao\r\nimport androidx.room.Insert\r\nimport androidx.room.OnConflictStrategy\r\nimport androidx.room.Query\r\nimport androidx.room.Transaction\r\nimport androidx.room.Update\r\nimport com.example.id.data.entities.WorkdayEvent\r\nimport kotlinx.coroutines.flow.Flow\r\nimport java.util.Date\r\n\r\n@Dao\r\ninterface WorkdayEventDao {\r\n    @Insert\r\n    suspend fun insertWorkdayEvent(event: WorkdayEvent): Long\r\n\r\n    @Update\r\n    suspend fun updateWorkdayEvent(event: WorkdayEvent)\r\n\r\n    @Query(\"SELECT * FROM workday_events WHERE userId = :userId ORDER BY startTime DESC\")\r\n    fun getAllWorkdayEvents(userId: String): Flow<List<WorkdayEvent>>\r\n\r\n    @Query(\"SELECT * FROM workday_events WHERE localId = :id\")\r\n    suspend fun getWorkdayEventById(id: Long): WorkdayEvent?\r\n\r\n    @Query(\"SELECT * FROM workday_events WHERE endTime IS NULL ORDER BY startTime DESC LIMIT 1\")\r\n    fun getActiveWorkdayEvent(): Flow<WorkdayEvent?>\r\n\r\n    @Query(\"SELECT * FROM workday_events WHERE userId = :userId AND endTime IS NULL ORDER BY startTime DESC LIMIT 1\")\r\n    fun getActiveWorkdayEvent(userId: String): Flow<WorkdayEvent?>\r\n\r\n    @Query(\"\"\"\r\n        SELECT * FROM workday_events\r\n        WHERE userId = :userId\r\n        AND (:startDate IS NULL OR startTime >= :startDate)\r\n        AND (:endDate IS NULL OR startTime < :endDate)\r\n        ORDER BY startTime DESC\r\n        \"\"\")\r\n    fun getWorkdayEventsForReport(userId: String, startDate: Date?, endDate: Date?): Flow<List<WorkdayEvent>>\r\n\r\n    @Query(\"DELETE FROM workday_events WHERE localId = :id\")\r\n    suspend fun deleteWorkdayEventById(id: Long)\r\n\r\n    @Query(\"SELECT * FROM workday_events WHERE userId = :userId AND carPlate LIKE '%' || :carPlate || '%'\" )\r\n    fun getWorkdayEventsByPlate(userId: String, carPlate: String): Flow<List<WorkdayEvent>>\r\n\r\n    @Query(\"SELECT * FROM workday_events WHERE userId = :userId AND startTime >= :sevenDaysAgo ORDER BY startTime DESC\")\r\n    suspend fun getWorkdayEventsAfter(userId: String, sevenDaysAgo: Date): List<WorkdayEvent>\r\n\r\n    @Query(\"SELECT * FROM workday_events WHERE isSynced = 0\")\r\n    suspend fun getUnsyncedWorkdayEvents(): List<WorkdayEvent>\r\n\r\n    @Query(\"UPDATE workday_events SET isSynced = 1 WHERE localId = :id\")\r\n    suspend fun setWorkdayEventSynced(id: Long)\r\n\r\n    @Transaction\r\n    suspend fun replaceWorkdayEvent(oldId: Long, newEvent: WorkdayEvent) {\r\n        deleteWorkdayEventById(oldId)\r\n        insertWorkdayEvents(listOf(newEvent))\r\n    }\r\n\r\n    @Query(\"DELETE FROM workday_events WHERE isSynced = 1\")\r\n    suspend fun clearSyncedData()\r\n\r\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\r\n    suspend fun insertWorkdayEvents(events: List<WorkdayEvent>)\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/id/data/dao/WorkdayEventDao.kt b/app/src/main/java/com/example/id/data/dao/WorkdayEventDao.kt
--- a/app/src/main/java/com/example/id/data/dao/WorkdayEventDao.kt	(revision 9604995b7771b9f4ca94c16cf274b2a878ba944d)
+++ b/app/src/main/java/com/example/id/data/dao/WorkdayEventDao.kt	(date 1764985174214)
@@ -22,7 +22,7 @@
     fun getAllWorkdayEvents(userId: String): Flow<List<WorkdayEvent>>
 
     @Query("SELECT * FROM workday_events WHERE localId = :id")
-    suspend fun getWorkdayEventById(id: Long): WorkdayEvent?
+    suspend fun getWorkdayEventById(id: Long?): WorkdayEvent?
 
     @Query("SELECT * FROM workday_events WHERE endTime IS NULL ORDER BY startTime DESC LIMIT 1")
     fun getActiveWorkdayEvent(): Flow<WorkdayEvent?>
@@ -40,7 +40,7 @@
     fun getWorkdayEventsForReport(userId: String, startDate: Date?, endDate: Date?): Flow<List<WorkdayEvent>>
 
     @Query("DELETE FROM workday_events WHERE localId = :id")
-    suspend fun deleteWorkdayEventById(id: Long)
+    suspend fun deleteWorkdayEventById(id: Long?)
 
     @Query("SELECT * FROM workday_events WHERE userId = :userId AND carPlate LIKE '%' || :carPlate || '%'" )
     fun getWorkdayEventsByPlate(userId: String, carPlate: String): Flow<List<WorkdayEvent>>
Index: app/src/main/java/com/example/id/worker/SyncWorker.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.id.worker\r\n\r\nimport android.content.Context\r\nimport android.content.SharedPreferences\r\nimport android.util.Log\r\nimport androidx.hilt.work.HiltWorker\r\nimport androidx.work.CoroutineWorker\r\nimport androidx.work.WorkerParameters\r\nimport com.example.id.AUTH_TOKEN_KEY\r\nimport com.example.id.data.AppRepository\r\nimport com.example.id.network.ApiService\r\nimport dagger.assisted.Assisted\r\nimport dagger.assisted.AssistedInject\r\n\r\n@HiltWorker\r\nclass SyncWorker @AssistedInject constructor(\r\n    @Assisted appContext: Context,\r\n    @Assisted workerParams: WorkerParameters,\r\n    private val repository: AppRepository,\r\n    private val apiService: ApiService,\r\n    private val prefs: SharedPreferences\r\n) : CoroutineWorker(appContext, workerParams) {\r\n\r\n    override suspend fun doWork(): Result {\r\n        val token = prefs.getString(AUTH_TOKEN_KEY, null)\r\n        if (token == null) {\r\n            Log.d(\"SyncWorker\", \"Token is null, aborting sync.\")\r\n            return Result.failure() // No token, no sync\r\n        }\r\n\r\n        return try {\r\n            // Workday events\r\n            val unsyncedWorkdayEvents = repository.getUnsyncedWorkdayEvents()\r\n            unsyncedWorkdayEvents.forEach { event ->\r\n                if (event.id == null) { // New event, not yet on server\r\n                    val response = apiService.postWorkday(event)\r\n                    if (response.isSuccessful && response.body() != null) {\r\n                        val serverEvent = response.body()!!\r\n                        val updatedEvent = event.copy(\r\n                            id = serverEvent.id,\r\n                            isSynced = true\r\n                        )\r\n                        repository.updateWorkdayEvent(updatedEvent)\r\n                    }\r\n                } else { // Existing event, needs update on server\r\n                    apiService.updateWorkday(event.id, event)\r\n                }\r\n            }\r\n\r\n            // Refuel events\r\n            val unsyncedRefuelEvents = repository.getUnsyncedRefuelEvents()\r\n            unsyncedRefuelEvents.forEach { event ->\r\n                if (event.id == null) { // New event, not yet on server\r\n                    val response = apiService.postRefuel(event)\r\n                    if (response.isSuccessful && response.body() != null) {\r\n                        val serverEvent = response.body()!!\r\n                        val updatedEvent = event.copy(\r\n                            id = serverEvent.id,\r\n                            isSynced = true\r\n                        )\r\n                        repository.updateRefuelEvent(updatedEvent)\r\n                    }\r\n                } else { // Existing event, needs update on server\r\n                    apiService.updateRefuel(event.id, event)\r\n                }\r\n            }\r\n\r\n            // Loading events\r\n            val unsyncedLoadingEvents = repository.getUnsyncedLoadingEvents()\r\n            unsyncedLoadingEvents.forEach { event ->\r\n                if (event.id == null) { // New event, not yet on server\r\n                    val response = apiService.postLoading(event)\r\n                    if (response.isSuccessful && response.body() != null) {\r\n                        val serverEvent = response.body()!!\r\n                        val updatedEvent = event.copy(\r\n                            id = serverEvent.id,\r\n                            isSynced = true\r\n                        )\r\n                        repository.updateLoadingEvent(updatedEvent)\r\n                    }\r\n                } else { // Existing event, needs update on server\r\n                    apiService.updateLoading(event.id, event)\r\n                }\r\n            }\r\n\r\n            Result.success()\r\n        } catch (e: Exception) {\r\n            Log.e(\"SyncWorker\", \"Sync failed\", e)\r\n            Result.retry()\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/id/worker/SyncWorker.kt b/app/src/main/java/com/example/id/worker/SyncWorker.kt
--- a/app/src/main/java/com/example/id/worker/SyncWorker.kt	(revision 9604995b7771b9f4ca94c16cf274b2a878ba944d)
+++ b/app/src/main/java/com/example/id/worker/SyncWorker.kt	(date 1764985027765)
@@ -32,25 +32,28 @@
             // Workday events
             val unsyncedWorkdayEvents = repository.getUnsyncedWorkdayEvents()
             unsyncedWorkdayEvents.forEach { event ->
-                if (event.id == null) { // New event, not yet on server
+                if (event.id == null) { // New event, POST to server
                     val response = apiService.postWorkday(event)
                     if (response.isSuccessful && response.body() != null) {
                         val serverEvent = response.body()!!
                         val updatedEvent = event.copy(
-                            id = serverEvent.id,
+                            id = serverEvent.id, // Update with server ID
                             isSynced = true
                         )
                         repository.updateWorkdayEvent(updatedEvent)
                     }
-                } else { // Existing event, needs update on server
-                    apiService.updateWorkday(event.id, event)
+                } else { // Existing event, PUT update to server
+                    val response = apiService.updateWorkday(event.id, event)
+                    if (response.isSuccessful) {
+                        repository.updateWorkdayEvent(event.copy(isSynced = true))
+                    }
                 }
             }
 
             // Refuel events
             val unsyncedRefuelEvents = repository.getUnsyncedRefuelEvents()
             unsyncedRefuelEvents.forEach { event ->
-                if (event.id == null) { // New event, not yet on server
+                if (event.id == null) { // New event, POST to server
                     val response = apiService.postRefuel(event)
                     if (response.isSuccessful && response.body() != null) {
                         val serverEvent = response.body()!!
@@ -60,15 +63,18 @@
                         )
                         repository.updateRefuelEvent(updatedEvent)
                     }
-                } else { // Existing event, needs update on server
-                    apiService.updateRefuel(event.id, event)
+                } else { // Existing event, PUT update to server
+                    val response = apiService.updateRefuel(event.id, event)
+                     if (response.isSuccessful) {
+                        repository.updateRefuelEvent(event.copy(isSynced = true))
+                    }
                 }
             }
 
             // Loading events
             val unsyncedLoadingEvents = repository.getUnsyncedLoadingEvents()
             unsyncedLoadingEvents.forEach { event ->
-                if (event.id == null) { // New event, not yet on server
+                if (event.id == null) { // New event, POST to server
                     val response = apiService.postLoading(event)
                     if (response.isSuccessful && response.body() != null) {
                         val serverEvent = response.body()!!
@@ -78,8 +84,11 @@
                         )
                         repository.updateLoadingEvent(updatedEvent)
                     }
-                } else { // Existing event, needs update on server
-                    apiService.updateLoading(event.id, event)
+                } else { // Existing event, PUT update to server
+                    val response = apiService.updateLoading(event.id, event)
+                     if (response.isSuccessful) {
+                        repository.updateLoadingEvent(event.copy(isSynced = true))
+                    }
                 }
             }
 
